# Playlist
## Оглавление
1. [Описание проекта](#Описание-проекта) 
2. [Пример использования](#Пример-использования)


## Описание проекта
Клиент-сервисная кроссплатформенная система по воспроизведению музыки 
с использованием центрального проффильного модуля(playlist_module). \
И клиентское приложение, и серверное написано на языке Golang. Данные пользователей, 
информация о сессиях и имеющиеся композиции хранятся на сервере. 
У пользователя буду текущий лист информации о треках и текущая композиция \
В роли хранилища информации выступает NoSQL база данных MongoDB.
В нём будут хранится данные пользователя, информация о музыке, а так же местоположение файла. 
Сами файла хранятся отдельно.\
Архитектура сетевого взаимодействия постороена на системе gRPC, 
а конфиденциальность передаваемых данных обеспечивается SSL/TLS соединением. \
За воспроизведение музыкальных дорожек отвественен кроссплатформенный модуль Oto/V2.
Для удобства пользования клиентской стороной был реализован консольный интерфейс. \
Сервер и клиент могут работать как в localhost, так и по внешней сети. 
Клиентское приложение принимает в качестве аргумента командной строки адресс сети и 
порт для подключения в формате х.х.х.х:х (при отсутствии параметра будет использован localhost:7777).
Серверно приложение принимает до 2 параметров: 1 - uri для подключения к базе данных, 2 - адресс сети
и порт для прослушивания сервером (если параметры не переданы, будут использованы значения mongodb://localhost:27017/ и localhost:7777)
(чтобы передать только 2-ой действительный параметр нужно поставить на 1 позицию символ '_'. Пример: ./bin _ param2 )

## Пример использования

### Сборка
Для демонстрации работы системы следуют выполнить следующие шаги:
#### Шаг 1
Установить требуемые проектом зависимости (аудио пакет в зависимости от системы https://github.com/hajimehoshi/oto, MongoDB)
#### Шаг 2
Сгенерировать сертификат, а также собрать бинарные файлы посредством запуска Makefile \
_$ make_
#### Шаг 3
Заполнить базу данных музыкальными композициями(коллекции Tracks и Files) \
_db.Tracks.insertOne({name:"track1",duration:5253725789,id:1})_ \
_db.Tracks.insertOne({name:"track2",duration:15253725789,id:2})_ \
_db.Tracks.insertOne({name:"track3",duration:26253725789,id:3})_ \
_db.Files.insertOne({id:1, path:'{YOUR_PATH}/mp3_1.mp3'})_ \
_db.Files.insertOne({id:2, path:'{YOUR_PATH}/mp3_1.mp3'})_ \
_db.Files.insertOne({id:3, path:'{YOUR_PATH}/mp3_1.mp3'})_ \
Для примера будем использовать 1 файл с разной длительностью.
#### Шаг 4
Запустить исходники сервера и клиента(можно на разных машинах, 
но тогда следует обеспечить им соединение по сети, к примеру через Nginx).
#### Шаг 5
Зарегистрировать или авторизовать пользователя через интерфейс клиента.
### Docker
собрать контейнер в Docker при помощи соответствующих докер файлов(_client _server)
и запустить с биндингом нужных портов.
### Docker compose
Для демонстрации работы системы следуют выполнить следующие шаги:
#### Шаг 1
Запустить сборку системы через docker compose через цель "docker_compose" в make
(может потребовать судо прав на некоторых системах) \
_$ make docker_compose_
#### Шаг 2
Во 2 терминале подключиться к контейнеру db и заполнить базу данными по примеру из примера Сборки \
_$ docker compose exec db sh_ \
#### Шаг 3
Во 3 терминале подключиться к контейнеру server и запустить сервер \
_$ docker compose exec server sh_ \
_$ ./server mongodb://db:27017/ server:7777_
#### Шаг 4
Во 4 терминале подключиться к контейнеру client, запустить client и начать использование \
_$ docker compose exec client sh_ \
_$ ./client server:7777_
